# Zadanie 4

![alt text](images/4_4.png)

Wyrobienie intuicji:

Rozważamy każde drzewo binarne, tak jakby. Za każdym razem zakładamy przypadek pesymistyczny - musimy szukać dalej, idąc najdroższą ścieżką.  
Dla drzew 2-wierzchołkowych, będzie to suma ich kosztów, bo którykolwiek z nich nie byłby rootem, to i tak zakładamy pesymistyczny przypadek - musimy sprawdzić, czy ten wierzchołek, który jest po lewo/prawo już spełnia warunki naszego zadania (bo root nie spełniał, pesymistycznie). W tym momencie wiemy, jaki jest minimalny koszt sprawdzenia przedziału !![i, i+1]!!.  
Dla drzew 3-wierzchołkowych, !![i, j (=i+1), k (=i+2)]!!, rozważamy każdy wierzchołek jako roota. Jeżeli !!i!! jest rootem, to sprawdzenie minimalnego kosztu to koszt !!i!! + minimalny koszt na przedziale !![j, k]!!. Jeżeli !!j!! jest rootem, to sprawdzenie minimalnego kosztu to koszt !!j!! + maksymalny z minimalnych kosztów na przedziale !![i, i]!! oraz !![k, k]!!. Bierzemy maksymalny z minimalnych, bo pesymistycznie zakładamy, że tam właśnie bedziemy musieli pójść. Jeżeli !!k!! jest rootem, sprawdzenie to koszt !!k!! + minimalny koszt sprawdzenia !![i, j]!!.  
No i tak robimy cały czas - na przedzale !![1, n]!!, każdy wierzchołek rozważamy jako roota, a minimalny koszt sprawdzenia jego prawego i lewego poddrzewa znamy, z tym że zakładamy że będziemy zmuszeni pójść do tego poddrzewa, które jest droższe.

Rozwiązujemy to dynamicznie - najpierw liczymy wszystkie przedziały o długości 1 (po prostu cena sprawdzenia tego elementu), później cena sprawdzenia przedziałów o długości dwa i tak dalej, typowo dynamicznie.

```python
def find_minimal_way(A, C):
    dp = arr[n x n]
    roots = arr[n x n]

    # prep - na przekątnej są koszty przedziału o długości 1, [i, i], jest to ich koszt
    for i in range(1, n+1):
        dp[i][i] = C[i]
        roots[i][i] = i

    for length in range(1, n+1):
        for start in range(1, n-length+2):
            min = math.infinity
            root = -1
            for i in range(start, start+length):
                # zakladam se ze pod przekatna sa zera,
                # bo nie chce mi sie dodawac warunku if left > right
                cost = C[i] + max(dp[l][i-1], dp[i+1][r])
                if cost < min:
                    min = cost
                    root = i
            dp[start][start+length] = min
            roots[start][start+length] = root

    result_queries = []
    def retrieve_queries(start, end):
        if start > end:
            return
        root = roots[start][end]
        result_queries.append(root)

        retrieve_queries(start, root - 1)
        retrieve_queries(root + 1, end)

    return dp[1][n], retrieve_queries(1, n)
```

Działa to w !!O(n^3)!!. Imo spoko, ale podobno raczej nieakceptowalne w grupach ambitniejszych i trzeba użyć jakiejś [optymalizacji Knutha](https://cp-algorithms.com/dynamic_programming/knuth-optimization.html), żeby to śmigało w !!O(n^2)!!.

# Zadanie 7

![alt text](images/4_7.png)

1. Robimy tablicę 3d - w 3 wymiarze przechowujemy najdłuższe podciągi zawierające jakiś fragment `aaabb` (przykładowy wzorzec, działa dla dowolnego T), np. `dp[3][7][2]` będzie przechowywać wartość najdłuższego wspólnego podciągu na indeksach !![3, 7]!!, zawierającego w sobie podciąg `aa`.

Nasz warunek dynamiczny dla takiego problemu będzie wyglądał:

1. kiedy !!x[i] \neq y[j]!! - robimy to co zwykle:
   $$ dp[i][j][k] = max(dp[i][j-1][k], dp[i-1][j][k]) $$

2. kiedy !!x[i] = y[j] \neq T[k]!! i na indeksach [i-1, j-1] istnieje podciąg zawierający podciąg T o długości k, tj. !!dp[i-1][j-1][k] > 0!!:
   $$ dp[i][j][k] = dp[i-1][j-1][k] + 1 $$

3. to co wyżej, ale na indeksach [i-1, j-1] podciąg T o długości k ma długość 0, tj. nie istnieje:
   $$ dp[i][j][k] = dp[i-1][j-1][k] $$

4. kiedy !!x[i] = y[j] = T[k]!!:
   $$ dp[i][j][k] = dp[i-1][j-1][k-1] + 1 $$
